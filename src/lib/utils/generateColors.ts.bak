import { ColorEntry } from './colorDatabase';
import { STATIC_COLOR_DATA } from './colorDataStatic';
import { COMPLETE_COLOR_DATA } from './completeColorData';
import { ACCURATE_COLOR_DATA } from './fixedAccurateColorData';

export interface Color {
  hex: string;
  rgb: { r: number; g: number; b: number };
  hsl: { h: number; s: number; l: number };
  name?: string;
}

// Add HARMONY_RULES constant for different color harmony patterns
const HARMONY_RULES = {
  triadic: {
    angles: [0, 120, 240],
    accents: 2
  },
  analogous: {
    angles: [-30, 0, 30],
    accents: 2
  },
  splitComplementary: {
    angles: [0, 150, 210],
    accents: 2
  },
  tetradic: {
    angles: [0, 90, 180, 270],
    accents: 2
  },
  monochromatic: {
    angles: [0],
    accents: 0
  }
};

// Add role-based color constraints after the HARMONY_RULES constant
interface ColorRoleConstraint {
  minLightness: number;
  maxLightness: number;
  minSaturation?: number;
  maxSaturation?: number;
}

const ROLE_CONSTRAINTS: Record<string, ColorRoleConstraint> = {
  dominant: { minLightness: 20, maxLightness: 40, maxSaturation: 70 },
  accent: { minLightness: 50, maxLightness: 70, minSaturation: 80 },
  neutral: { minLightness: 60, maxLightness: 80, maxSaturation: 30 },
  highlight: { minLightness: 80, maxLightness: 95, minSaturation: 50 },
  transition: { minLightness: 40, maxLightness: 60, minSaturation: 60 }
};

// Define minimum contrast ratio for adjacent colors
const MIN_CONTRAST_RATIO = 4.0; // Improved from 3.0 to better meet accessibility standards

// Improve the minimum spacing value for better distribution
const MIN_HUE_SPACING = 72; // Ensure colors are at least 72° apart on the hue wheel

// Define temperature ranges for warm, cool, and neutral colors
const TEMPERATURE_RANGES = {
  warm: { minHue: 0, maxHue: 60 },
  cool: { minHue: 180, maxHue: 300 },
  neutral: { minHue: 0, maxHue: 360 }
};

// Define saturation ranges for different color roles
const SATURATION_RANGES = {
  dominant: [40, 60],   // Base/dominant colors - moderate saturation
  accent: [70, 90],     // Accent colors - high saturation
  neutral: [10, 30],    // Neutral colors - low saturation
  highlight: [50, 70],  // Highlight colors - moderate-high saturation
  transition: [30, 50]  // Transition colors - moderate-low saturation
};

function hexToHSL(hex: string): { h: number; s: number; l: number } {
  // Remove the hash if it exists
  hex = hex.replace('#', '');
  
  // Convert hex to RGB
  const r = parseInt(hex.substring(0, 2), 16) / 255;
  const g = parseInt(hex.substring(2, 4), 16) / 255;
  const b = parseInt(hex.substring(4, 6), 16) / 255;
  
  // Find min and max values
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  
  // Calculate lightness
  let l = (max + min) / 2;
  
  // Calculate saturation
  let s = 0;
  if (max !== min) {
    s = l > 0.5 ? (max - min) / (2 - max - min) : (max - min) / (max + min);
  }
  
  // Calculate hue
  let h = 0;
  if (max !== min) {
    switch (max) {
      case r:
        h = (g - b) / (max - min) + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / (max - min) + 2;
        break;
      case b:
        h = (r - g) / (max - min) + 4;
        break;
    }
    h /= 6;
  }
  
  // Convert to degrees and percentages
  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    l: Math.round(l * 100)
  };
}

function calculateContrast(rgb1: { r: number, g: number, b: number }, rgb2: { r: number, g: number, b: number }): number {
  // Calculate relative luminance for both colors
  const getLuminance = (rgb: { r: number, g: number, b: number }) => {
    const sRGB = [rgb.r / 255, rgb.g / 255, rgb.b / 255].map(val => {
      return val <= 0.03928
        ? val / 12.92
        : Math.pow((val + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * sRGB[0] + 0.7152 * sRGB[1] + 0.0722 * sRGB[2];
  };
  
  const luminance1 = getLuminance(rgb1);
  const luminance2 = getLuminance(rgb2);
  
  const brightest = Math.max(luminance1, luminance2);
  const darkest = Math.min(luminance1, luminance2);
  
  return (brightest + 0.05) / (darkest + 0.05);
}

// Update the enforceHueSpacing function to ensure better distribution
function enforceHueSpacing(hues: number[], minSpacing: number = MIN_HUE_SPACING): number[] {
  if (hues.length <= 1) return hues;
  
  const adjustedHues = [...hues];
  
  // First pass: ensure all colors meet minimum spacing requirements
  for (let i = 0; i < adjustedHues.length; i++) {
    for (let j = i + 1; j < adjustedHues.length; j++) {
      const hueDiff = Math.min(
        Math.abs(adjustedHues[i] - adjustedHues[j]),
        360 - Math.abs(adjustedHues[i] - adjustedHues[j])
      );
      
      if (hueDiff < minSpacing) {
        // If hues are too close, adjust the later hue
        const clockwise = (adjustedHues[i] + minSpacing) % 360;
        const counterClockwise = (adjustedHues[i] - minSpacing + 360) % 360;
        
        // Choose the direction that creates the least conflict with other colors
        const clockwiseConflicts = adjustedHues.filter(h => h !== adjustedHues[j]).some(h => 
          Math.min(Math.abs(clockwise - h), 360 - Math.abs(clockwise - h)) < minSpacing
        );
        
        const counterClockwiseConflicts = adjustedHues.filter(h => h !== adjustedHues[j]).some(h => 
          Math.min(Math.abs(counterClockwise - h), 360 - Math.abs(counterClockwise - h)) < minSpacing
        );
        
        if (!clockwiseConflicts) {
          adjustedHues[j] = clockwise;
        } else if (!counterClockwiseConflicts) {
          adjustedHues[j] = counterClockwise;
        } else {
          // If both directions conflict, choose the one with larger spacing
          let maxClockwiseSpace = 360;
          let maxCounterClockwiseSpace = 360;
          
          for (let k = 0; k < adjustedHues.length; k++) {
            if (k !== j) {
              const cwDiff = Math.min(
                Math.abs(clockwise - adjustedHues[k]),
                360 - Math.abs(clockwise - adjustedHues[k])
              );
              
              const ccwDiff = Math.min(
                Math.abs(counterClockwise - adjustedHues[k]),
                360 - Math.abs(counterClockwise - adjustedHues[k])
              );
              
              maxClockwiseSpace = Math.min(maxClockwiseSpace, cwDiff);
              maxCounterClockwiseSpace = Math.min(maxCounterClockwiseSpace, ccwDiff);
            }
          }
          
          adjustedHues[j] = maxClockwiseSpace >= maxCounterClockwiseSpace ? clockwise : counterClockwise;
        }
      }
    }
  }
  
  return adjustedHues;
}

// Add a function to distribute lightness values for better hierarchy
function distributeLightness(count: number): number[] {
  // Create a balanced distribution from dark to light with randomized variance
  const minLightness = 15 + (Math.random() * 10 - 5); // 10-20
  const maxLightness = 85 + (Math.random() * 10 - 5); // 80-90
  const range = maxLightness - minLightness;
  
  // Ensure we have a good mix of dark, medium, and light colors
  const lightness: number[] = [];
  
  // Random seed for this specific palette
  const seed = Math.random();
  
  if (count <= 3) {
    // For small palettes, ensure clear contrast with dark, medium, light
    // but with randomness
    lightness.push(minLightness + range * (0.1 + seed * 0.15));  // Dark with variance
    if (count >= 2) lightness.push(minLightness + range * (0.5 + (seed - 0.5) * 0.2));  // Medium with variance
    if (count >= 3) lightness.push(minLightness + range * (0.9 - seed * 0.15));  // Light with variance
  } else {
    // For larger palettes, create a more varied distribution
    
    // Randomly determine if we want more light, dark, or balanced colors
    const paletteStyle = Math.random();
    
    // Create anchor points with randomness
    if (paletteStyle < 0.33) {
      // Bias toward darker colors
      lightness.push(minLightness + range * (0.05 + Math.random() * 0.1));  // Very dark
      lightness.push(minLightness + range * (0.3 + Math.random() * 0.15));  // Dark-medium
      lightness.push(minLightness + range * (0.6 + Math.random() * 0.2));   // Medium-light
    } else if (paletteStyle < 0.66) {
      // Bias toward lighter colors
      lightness.push(minLightness + range * (0.25 + Math.random() * 0.15)); // Dark-medium
      lightness.push(minLightness + range * (0.55 + Math.random() * 0.15)); // Medium-light
      lightness.push(minLightness + range * (0.85 + Math.random() * 0.1));  // Very light
    } else {
      // More balanced distribution
      lightness.push(minLightness + range * (0.15 + Math.random() * 0.1));  // Dark
      lightness.push(minLightness + range * (0.5 + (Math.random() * 0.2 - 0.1))); // Medium
      lightness.push(minLightness + range * (0.85 + Math.random() * 0.1));  // Light
    }
    
    // Fill in remaining values with randomized spacing
    const remainingValues = count - 3;
    if (remainingValues > 0) {
      // Create a "jitter" array for random offsets
      const jitterAmount = 12;
      const jitter = Array(remainingValues).fill(0).map(() => 
        Math.random() * jitterAmount - (jitterAmount / 2)
      );
      
      for (let i = 0; i < remainingValues; i++) {
        // Instead of even spacing, use golden ratio to create more interesting distribution
        const goldenRatio = 0.618033988749895;
        let position = (i * goldenRatio) % 1.0;
        
        // Apply jitter for less predictable results
        position = Math.max(0, Math.min(0.99, position + (jitter[i] / 100)));
        
        // Calculate lightness value
        const val = minLightness + (range * position);
        
        // Avoid values too close to existing ones
        const tooClose = lightness.some(l => Math.abs(l - val) < 8);
        
        if (!tooClose) {
          lightness.push(val);
        } else {
          // If too close to an existing value, offset it
          lightness.push(val + 12 + (Math.random() * 6 - 3));
        }
      }
    }
    
    // Sort from darkest to lightest
    lightness.sort((a, b) => a - b);
  }
  
  // Round to nearest integer and ensure all values are within range
  return lightness.map(l => Math.max(minLightness, Math.min(maxLightness, Math.round(l))));
}

// Add a function to create a balanced saturation distribution
function distributeSaturation(count: number, baseS: number): number[] {
  const saturation: number[] = [];
  
  // Ensure we have a mix of low, medium, and high saturation values
  // with at least one muted and one vibrant color
  
  // Define bounds with added randomness
  const randomOffset = Math.random() * 20 - 10; // -10 to +10 random offset
  const minSaturation = Math.max(15, baseS - 40 + randomOffset);
  const maxSaturation = Math.min(100, baseS + 30 + randomOffset);
  
  // Generate a unique seed for this palette to ensure variety
  const seed = Math.random();
  
  if (count <= 3) {
    // For small palettes, have clear saturation roles but with variance
    saturation.push(Math.min(30, minSaturation) + (seed * 15));  // Low (muted) with variance
    if (count >= 2) saturation.push(baseS + (seed * 10 - 5));    // Medium (base) with variance
    if (count >= 3) saturation.push(maxSaturation - (seed * 15)); // High (vibrant) with variance
  } else {
    // For accent color (usually one) - add randomness
    saturation.push(maxSaturation - (Math.random() * 10));
    
    // For neutral/muted color (usually one) - add randomness
    saturation.push(minSaturation + (Math.random() * 15));
    
    // For dominant/base color - add randomness
    const dominantSat = Math.min(75, Math.max(35, baseS + (Math.random() * 10 - 5)));
    saturation.push(dominantSat);
    
    // Fill in remaining colors with more randomized saturation values
    for (let i = 3; i < count; i++) {
      // Create more unpredictable pattern instead of simple alternating
      const randomFactor = Math.random();
      
      if (randomFactor < 0.33) {
        // More saturated
        saturation.push(Math.min(95, baseS + 15 + (Math.random() * 20)));
      } else if (randomFactor < 0.66) {
        // Mid saturation
        saturation.push(Math.min(80, Math.max(40, baseS + (Math.random() * 30 - 15))));
      } else {
        // More muted
        saturation.push(Math.max(25, baseS - 15 - (Math.random() * 15)));
      }
    }
    
    // Shuffle the saturation values (except for the first one which is the base color)
    for (let i = 1; i < saturation.length; i++) {
      const j = 1 + Math.floor(Math.random() * (saturation.length - 1));
      [saturation[i], saturation[j]] = [saturation[j], saturation[i]];
    }
  }
  
  // Ensure all values are within valid range
  return saturation.map(s => Math.max(10, Math.min(100, Math.round(s))));
}

// Add a function to scale saturation based on color role
function scaleSaturation(hsl: { h: number; s: number; l: number }, role: string): { h: number; s: number; l: number } {
  const range = SATURATION_RANGES[role as keyof typeof SATURATION_RANGES] || [30, 70];
  const [min, max] = range;
  
  // Use a more balanced approach for saturation
  // Take into account the existing saturation but bias toward the role-appropriate range
  const targetSaturation = min + (max - min) * (Math.random() * 0.6 + 0.2); // Avoid extremes
  
  // Blend existing saturation with target 
  const newSaturation = Math.round((hsl.s * 0.3) + (targetSaturation * 0.7));
  
  return {
    ...hsl,
    s: Math.max(min, Math.min(max, newSaturation))
  };
}

// Add a function to adjust color temperature
function adjustTemperature(
  colors: Color[],
  temperature: 'warm' | 'cool' | 'neutral' | 'mixed' = 'mixed'
): Color[] {
  if (temperature === 'mixed') return colors;
  
  const range = TEMPERATURE_RANGES[temperature];
  
  return colors.map((color, index) => {
    // Skip adjustment for specific roles
    if (color.name || index === 0) return color; // Don't adjust named colors or base color
    
    const hue = color.hsl.h;
    
    // Check if the hue needs adjustment
    if (temperature === 'neutral') {
      // For neutral, we don't adjust hue but might desaturate a bit
      const newSaturation = Math.max(20, color.hsl.s - 15);
      const newHsl = { ...color.hsl, s: newSaturation };
      const newRgb = hslToRgb(newHsl.h, newHsl.s, newHsl.l);
      const newHex = hslToHex(newHsl.h, newHsl.s, newHsl.l);
      
      return { ...color, hsl: newHsl, rgb: newRgb, hex: newHex };
    }
    
    // For warm/cool, adjust hue to be within range
    // But only if it's far outside the range
    if (temperature === 'warm' && (hue > 90 && hue < 270)) {
      // Far from warm range, shift toward warm
      const targetHue = Math.random() < 0.5 ? 
        Math.max(range.minHue, Math.min(range.minHue + 30, hue - 180)) :
        Math.max(range.maxHue - 30, Math.min(range.maxHue, hue - 180));
      
      const newHsl = { ...color.hsl, h: targetHue };
      const newRgb = hslToRgb(newHsl.h, newHsl.s, newHsl.l);
      const newHex = hslToHex(newHsl.h, newHsl.s, newHsl.l);
      
      return { ...color, hsl: newHsl, rgb: newRgb, hex: newHex };
    }
    
    if (temperature === 'cool' && (hue < 150 || hue > 330)) {
      // Far from cool range, shift toward cool
      const targetHue = hue < 150 ?
        Math.max(range.minHue, Math.min(range.maxHue, hue + 180)) :
        Math.max(range.minHue, Math.min(range.maxHue, hue - 180));
      
      const newHsl = { ...color.hsl, h: targetHue };
      const newRgb = hslToRgb(newHsl.h, newHsl.s, newHsl.l);
      const newHex = hslToHex(newHsl.h, newHsl.s, newHsl.l);
      
      return { ...color, hsl: newHsl, rgb: newRgb, hex: newHex };
    }
    
    return color;
  });
}

// Update the validateAndImproveContrast function to be more aggressive with contrast optimization
function validateAndImproveContrast(colors: Color[]): Color[] {
  if (colors.length <= 1) return colors;
  
  const improvedColors = [...colors];
  
  // First, calculate perceptual luminance for all colors
  const luminances = improvedColors.map(color => {
    const r = color.rgb.r / 255;
    const g = color.rgb.g / 255;
    const b = color.rgb.b / 255;
    
    // Use perceived luminance formula
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  });
  
  // Check and improve contrast between adjacent colors
  for (let i = 0; i < improvedColors.length - 1; i++) {
    const color1 = improvedColors[i];
    const color2 = improvedColors[i + 1];
    
    let contrast = calculateContrast(color1.rgb, color2.rgb);
    let attempts = 0;
    
    // Try to improve contrast if below minimum - with more attempts
    while (contrast < MIN_CONTRAST_RATIO && attempts < 12) {
      attempts++;
      
      // Calculate luminance difference to determine which direction to adjust
      const lum1 = luminances[i];
      const lum2 = luminances[i + 1];
      const lumDiff = Math.abs(lum1 - lum2);
      
      // If luminance difference is very small, make more aggressive adjustments
      const adjustmentAmount = lumDiff < 0.2 ? 12 : 8;
      
      // Determine which color to adjust based on existing brightness and position
      // Generally prefer to adjust:
      // 1. The color with less extreme lightness
      // 2. The color that's not named (if one is named)
      // 3. Secondary colors over primary or base colors
      
      let adjustIndex: number;
      let adjustLighter: boolean;
      
      if (color1.name && !color2.name) {
        // If color1 is named but color2 isn't, adjust color2
        adjustIndex = i + 1;
        adjustLighter = lum2 < 0.5; // Make color2 lighter if it's dark, darker if it's light
      } else if (!color1.name && color2.name) {
        // If color2 is named but color1 isn't, adjust color1
        adjustIndex = i;
        adjustLighter = lum1 < 0.5; // Make color1 lighter if it's dark, darker if it's light
      } else {
        // If both are named or neither is named, choose based on luminance
        // Determine which color is in the middle range and adjust that one
        const lum1Distance = Math.abs(lum1 - 0.5);
        const lum2Distance = Math.abs(lum2 - 0.5);
        
        if (lum1Distance <= lum2Distance) {
          // Adjust color1 if it's closer to middle luminance
          adjustIndex = i;
          adjustLighter = lum1 < lum2; // Move away from color2
        } else {
          // Adjust color2 if it's closer to middle luminance
          adjustIndex = i + 1;
          adjustLighter = lum2 < lum1; // Move away from color1
        }
      }
      
      const colorToAdjust = improvedColors[adjustIndex];
      
      // Calculate new lightness - make larger adjustments when needed
      // For very low contrast, make more extreme adjustments
      const newL = adjustLighter 
        ? Math.min(colorToAdjust.hsl.l + adjustmentAmount, 92) // Make lighter
        : Math.max(colorToAdjust.hsl.l - adjustmentAmount, 15); // Make darker
      
      // Update the adjusted color
      const newHsl = { ...colorToAdjust.hsl, l: newL };
      const newRgb = hslToRgb(newHsl.h, newHsl.s, newHsl.l);
      const newHex = hslToHex(newHsl.h, newHsl.s, newHsl.l);
      
      // Update the color
      improvedColors[adjustIndex] = { ...improvedColors[adjustIndex], hsl: newHsl, rgb: newRgb, hex: newHex };
      
      // Update the luminance
      luminances[adjustIndex] = 0.2126 * (newRgb.r / 255) + 0.7152 * (newRgb.g / 255) + 0.0722 * (newRgb.b / 255);
      
      // Recalculate contrast
      contrast = calculateContrast(
        improvedColors[i].rgb,
        improvedColors[i + 1].rgb
      );
    }
  }
  
  return improvedColors;
}

// Function to apply harmony rules to generate balanced hues
function applyHarmonyRule(baseHue: number, ruleName: keyof typeof HARMONY_RULES, numColors: number): number[] {
  const rule = HARMONY_RULES[ruleName];
  const hues: number[] = [];
  
  // Generate hues based on the harmony rule
  for (let i = 0; i < numColors; i++) {
    // For fewer colors than angles, pick a subset
    // For more colors than angles, repeat the pattern
    const angleIndex = i % rule.angles.length;
    const angle = rule.angles[angleIndex];
    hues.push((baseHue + angle + 360) % 360);
  }
  
  return hues;
}

// Update generateColorsByType to incorporate saturation scaling and role assignment
function generateColorsByType(
  baseHSL: { h: number; s: number; l: number },
  numColors: number,
  paletteType: 'monochromatic' | 'complementary' | 'analogous' | 'triadic' | 'tetradic' | 'splitComplementary'
): Color[] {
  const colors: Color[] = [];
  
  // Generate hues based on the harmony type
  let hues: number[] = [];
  
  switch (paletteType) {
    case 'monochromatic':
      // Completely new monochromatic palette generation with dramatic variety in S/L values
      // Start with the base hue
      
      // Allow tiny hue variations for more interesting monochromatic palettes
      // (still appears monochromatic but adds depth)
      const hueVariance = Math.random() * 10 - 5; // ±5° maximum variation
      
      // Choose a strategy for this specific palette
      const monoStrategy = Math.floor(Math.random() * 6);
      
      // Generate hues with slight variations
      hues = Array(numColors).fill(0).map((_, i) => {
        if (i === 0) return baseHSL.h; // Keep exact base hue
        
        // Apply tiny random variations based on strategy
        let variance;
        
        switch (monoStrategy) {
          case 0: // "Pure" - exactly the same hue
            variance = 0;
            break;
          case 1: // "Micro Shift" - tiny consistent shifts
            variance = hueVariance * (i / numColors);
            break;
          case 2: // "Warm Bias" - shifts toward warmer
            variance = Math.random() * 3 - 1; // -1 to +2 (biased warm)
            break;
          case 3: // "Cool Bias" - shifts toward cooler
            variance = Math.random() * 3 - 2; // -2 to +1 (biased cool)
            break;
          case 4: // "Random Micro" - tiny random per color
            variance = (Math.random() * 2 - 1) * hueVariance;
            break;
          case 5: // "Alternating" - alternate warm/cool
            variance = (i % 2 === 0) ? hueVariance : -hueVariance;
            break;
          default:
            variance = 0;
        }
        
        return (baseHSL.h + variance + 360) % 360;
      });
      
      // Now prepare for dramatic variations in saturation and lightness
      // These will be applied in the color assignment phase
      // Save the strategy so it can be reused there
      const satLightStrategy = Math.floor(Math.random() * 8);
      
      // Store the strategy in an extra property for later use
      (hues as any).satLightStrategy = satLightStrategy;
      (hues as any).baseS = baseHSL.s;
      (hues as any).baseL = baseHSL.l;
      break;
    case 'complementary':
      // Massive overhaul of complementary palette generation with extreme variety
      hues = [baseHSL.h];
      
      // Choose from many completely different strategies for true diversity
      const compStrategy = Math.floor(Math.random() * 12); // Increased strategy count
      
      switch (compStrategy) {
        case 0: // "Classic Split" - with extreme randomization
          // Use a drastically different complementary angle each time
          const complementOffset = Math.random() * 80 - 40; // -40 to +40 degree offset
          const complement = (baseHSL.h + 180 + complementOffset) % 360;
          hues.push(complement);
          
          // Add wildly varied colors for larger palettes
          if (numColors > 2) {
            for (let i = 2; i < numColors; i++) {
              // Use completely unique hues with large spacing
              const randomOffset = Math.random() * 360;
              let newHue = (baseHSL.h + randomOffset) % 360;
              
              // Check minimum distance from existing hues to ensure diversity
              let tooClose = false;
              for (const h of hues) {
                const distance = Math.min(Math.abs(newHue - h), 360 - Math.abs(newHue - h));
                if (distance < 30) {
                  tooClose = true;
                  break;
                }
              }
              
              // If too close, try a completely different approach
              if (tooClose) {
                newHue = (baseHSL.h + 120 * i) % 360;
              }
              
              hues.push(newHue);
            }
          }
          break;
          
        case 1: // "Triadic Plus" - use triadic with dramatic variance
          const triadicComplementBase = (baseHSL.h + 180) % 360;
          
          // Create two additional points to form a triad
          const triad1 = (baseHSL.h + 120 + (Math.random() * 60 - 30)) % 360;
          const triad2 = (baseHSL.h + 240 + (Math.random() * 60 - 30)) % 360;
          
          // Add both split complements to ensure diversity
          hues.push(triadicComplementBase);
          
          // Add remaining triadic points if needed
          if (numColors > 2) hues.push(triad1);
          if (numColors > 3) hues.push(triad2);
          
          // Add even more diversity for larger palettes
          for (let i = 4; i < numColors; i++) {
            // Generate a completely random color
            let newHue = Math.random() * 360;
            hues.push(newHue);
          }
          break;
          
        case 2: // "Multi-Complement" - use multiple complementary angles
          // Use a much wider range of complementary angles
          const angles = [90, 120, 150, 180, 210, 240, 270];
          
          // Add extreme randomization to each angle
          const randomizedAngles = angles.map(a => 
            (baseHSL.h + a + (Math.random() * 60 - 30)) % 360
          );
          
          // Shuffle for unpredictability
          randomizedAngles.sort(() => Math.random() - 0.5);
          
          // Take as many as needed with full random selection
          for (let i = 0; i < Math.min(numColors - 1, randomizedAngles.length); i++) {
            hues.push(randomizedAngles[i]);
          }
          break;
        
        case 3: // "Dramatic Contrast" - focus on extreme contrast
          // Use extreme saturation and value differences
          const exactComplement = (baseHSL.h + 180) % 360;
          hues.push(exactComplement);
          
          if (numColors > 2) {
            // Add vibrant accent colors from widely separated parts of the wheel
            const vibrantHues = [
              0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330
            ];
            
            // Add randomization to each
            const randomizedVibrantHues = vibrantHues.map(h => 
              (h + (Math.random() * 30 - 15)) % 360
            );
            
            // Shuffle and take what we need
            randomizedVibrantHues.sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < Math.min(numColors - 2, randomizedVibrantHues.length); i++) {
              hues.push(randomizedVibrantHues[i]);
            }
          }
          break;
          
        case 4: // "Full Spectrum" - use a full spectrum distribution
          // Use golden ratio to distribute colors around the wheel
          const goldenRatio = 0.618033988749895;
          
          // Generate at least one complement
          hues.push((baseHSL.h + 180 + (Math.random() * 40 - 20)) % 360);
          
          // Use golden ratio to generate remaining colors
          for (let i = 2; i < numColors; i++) {
            // Use golden ratio with i as multiplier for full distribution
            const hue = (baseHSL.h + (360 * (i * goldenRatio))) % 360;
            hues.push(hue);
          }
          break;
          
        case 5: // "Quantum Jump" - completely different hues each time
          // Generate completely random hues with no relation to base color
          for (let i = 1; i < numColors; i++) {
            const randomHue = Math.random() * 360;
            hues.push(randomHue);
          }
          break;
          
        case 6: // "Natural Palette" - earthy/nature tones
          // Shift base color toward earthy tones
          const earthyBase = (baseHSL.h + (Math.random() * 40 - 20)) % 360;
          
          // Create earthy palette with ochres, greens, browns
          const earthyHues = [
            20 + (Math.random() * 20), // Yellow-orange/ochre (20-40)
            100 + (Math.random() * 40), // Yellow-green/sage (100-140)
            30 + (Math.random() * 15),  // Orange-brown (30-45)
            5 + (Math.random() * 10),   // Red-brown (5-15)
            210 + (Math.random() * 30)  // Blue-grey (210-240)
          ];
          
          // Shuffle and take what we need
          earthyHues.sort(() => Math.random() - 0.5);
          
          for (let i = 0; i < Math.min(numColors - 1, earthyHues.length); i++) {
            hues.push(earthyHues[i]);
          }
          break;
          
        case 7: // "Retro Wave" - 80s/90s inspired neon and pastels
          // Neon colors and pastels
          const retroHues = [
            320 + (Math.random() * 20), // Hot pink/magenta (320-340)
            190 + (Math.random() * 30), // Cyan (190-220)
            280 + (Math.random() * 20), // Purple (280-300)
            50 + (Math.random() * 20),  // Yellow (50-70)
            160 + (Math.random() * 20)  // Teal (160-180)
          ];
          
          // Shuffle and take what we need 
          retroHues.sort(() => Math.random() - 0.5);
          
          for (let i = 0; i < Math.min(numColors - 1, retroHues.length); i++) {
            hues.push(retroHues[i]);
          }
          break;
          
        case 8: // "Modern Web" - contemporary web palette
          // Modern web design colors
          const modernHues = [
            210 + (Math.random() * 30), // Blue (210-240)
            150 + (Math.random() * 30), // Teal/turquoise (150-180)
            330 + (Math.random() * 20), // Pink (330-350)
            40 + (Math.random() * 20),  // Orange (40-60)
            270 + (Math.random() * 20)  // Purple (270-290)
          ];
          
          // Shuffle and take what we need
          modernHues.sort(() => Math.random() - 0.5);
          
          for (let i = 0; i < Math.min(numColors - 1, modernHues.length); i++) {
            hues.push(modernHues[i]);
          }
          break;
          
        case 9: // "Primary Focus" - focus on primary and secondary colors
          // Primary/secondary color wheel
          const primaryHues = [
            0,       // Red
            60,      // Yellow
            120,     // Green
            180,     // Cyan
            240,     // Blue
            300      // Magenta
          ];
          
          // Add slight randomization
          const randomizedPrimaryHues = primaryHues.map(h => 
            (h + (Math.random() * 20 - 10)) % 360
          );
          
          // Shuffle and take what we need
          randomizedPrimaryHues.sort(() => Math.random() - 0.5);
          
          for (let i = 0; i < Math.min(numColors - 1, randomizedPrimaryHues.length); i++) {
            hues.push(randomizedPrimaryHues[i]);
          }
          break;
          
        case 10: // "Jewel Tones" - rich, deep colors
          // Jewel-tone hues with randomization
          const jewelHues = [
            350 + (Math.random() * 20), // Ruby red (350-10)
            280 + (Math.random() * 20), // Amethyst (280-300)
            200 + (Math.random() * 20), // Sapphire (200-220)
            120 + (Math.random() * 20), // Emerald (120-140)
            40 + (Math.random() * 20)   // Amber/Topaz (40-60)
          ];
          
          // Shuffle and take what we need
          jewelHues.sort(() => Math.random() - 0.5);
          
          for (let i = 0; i < Math.min(numColors - 1, jewelHues.length); i++) {
            hues.push(jewelHues[i]);
          }
          break;
          
        case 11: // "Season" - seasonal color schemes
          // Choose a random season
          const seasons = ["spring", "summer", "autumn", "winter"];
          const season = seasons[Math.floor(Math.random() * seasons.length)];
          
          let seasonalHues: number[] = [];
          
          if (season === "spring") {
            seasonalHues = [
              60 + (Math.random() * 20),  // Yellow-green
              330 + (Math.random() * 30), // Pink/blossom
              190 + (Math.random() * 30), // Sky blue
              40 + (Math.random() * 20),  // Yellow
              280 + (Math.random() * 20)  // Purple/lavender
            ];
          } else if (season === "summer") {
            seasonalHues = [
              200 + (Math.random() * 40), // Ocean blue
              120 + (Math.random() * 30), // Vibrant green
              350 + (Math.random() * 20), // Hot pink/red
              40 + (Math.random() * 20),  // Sunny yellow
              220 + (Math.random() * 20)  // Dark blue
            ];
          } else if (season === "autumn") {
            seasonalHues = [
              25 + (Math.random() * 15),  // Orange
              0 + (Math.random() * 10),   // Red
              45 + (Math.random() * 15),  // Yellow-orange
              80 + (Math.random() * 20),  // Olive
              15 + (Math.random() * 10)   // Burnt orange
            ];
          } else { // winter
            seasonalHues = [
              210 + (Math.random() * 30), // Cold blue
              270 + (Math.random() * 20), // Purple
              180 + (Math.random() * 20), // Teal
              300 + (Math.random() * 20), // Magenta
              240 + (Math.random() * 20)  // Deep blue
            ];
          }
          
          // Shuffle and take what we need
          seasonalHues.sort(() => Math.random() - 0.5);
          
          for (let i = 0; i < Math.min(numColors - 1, seasonalHues.length); i++) {
            hues.push(seasonalHues[i]);
          }
          break;
      }
      break;
    case 'analogous':
      // Completely new analogous palette generation with dramatic variety
      // Start with the base hue
      hues = [baseHSL.h];
      
      // Choose from multiple dramatically different strategies
      const analogStrategy = Math.floor(Math.random() * 6);
      
      switch (analogStrategy) {
        case 0: // "Classic Analogous with Extreme Variance"
          // Generate a highly randomized range for this specific palette
          const rangeWidth = Math.random() * 80 + 20; // 20-100° total range
          
          // Decide whether to favor one side or balance
          const rightBias = Math.random() > 0.5;
          const leftRatio = rightBias ? 0.3 : 0.7;
          
          // Calculate range on each side
          const leftRange = rangeWidth * leftRatio;
          const rightRange = rangeWidth * (1 - leftRatio);
          
          // Distribute the remaining colors
          const remaining = numColors - 1;
          const leftCount = Math.floor(remaining * leftRatio);
          const rightCount = remaining - leftCount;
          
          // Add colors to the left side with increasing distance
          for (let i = 0; i < leftCount; i++) {
            // Non-linear distribution for more variety
            const position = Math.pow((i + 1) / (leftCount + 1), 1.5);
            const angle = leftRange * position;
            // Add randomness
            const jitter = Math.random() * 10 - 5;
            hues.push((baseHSL.h - angle - jitter + 360) % 360);
          }
          
          // Add colors to the right side with increasing distance
          for (let i = 0; i < rightCount; i++) {
            // Non-linear distribution
            const position = Math.pow((i + 1) / (rightCount + 1), 1.5);
            const angle = rightRange * position;
            // Add randomness
            const jitter = Math.random() * 10 - 5;
            hues.push((baseHSL.h + angle + jitter) % 360);
          }
          break;
          
        case 1: // "Color Family with Outlier"
          // Create a tight family of colors with one outlier for interest
          // Generate a narrower range for the family
          const familyWidth = Math.random() * 30 + 15; // 15-45° family width
          
          // Place the outlier at a larger distance
          const outlierDistance = Math.random() * 60 + 60; // 60-120° away
          const outlierDirection = Math.random() > 0.5 ? 1 : -1;
          const outlierHue = (baseHSL.h + (outlierDistance * outlierDirection) + 360) % 360;
          
          // First, add the family colors
          const familyCount = numColors - 2; // Base + outlier + family
          
          for (let i = 0; i < familyCount; i++) {
            // Distribute evenly within family range
            const position = ((i + 1) / (familyCount + 1)) - 0.5; // -0.5 to 0.5
            const angle = familyWidth * position;
            // Add slight randomness
            const jitter = Math.random() * 5 - 2.5;
            hues.push((baseHSL.h + angle + jitter + 360) % 360);
          }
          
          // Add the outlier
          hues.push(outlierHue);
          break;
          
        case 2: // "Stepped Analogous"
          // Create distinct steps with large gaps between groups
          
          // Divide the remaining colors into 2-3 groups
          const groupCount = numColors <= 5 ? 2 : 3;
          const colorsByGroup = [];
          
          // Allocate colors to groups
          let colorsRemaining = numColors - 1; // Excluding base color
          for (let i = 0; i < groupCount; i++) {
            // Last group gets all remaining colors
            if (i === groupCount - 1) {
              colorsByGroup[i] = colorsRemaining;
            } else {
              // Other groups get an approximately even distribution
              const groupSize = Math.floor(colorsRemaining / (groupCount - i));
              colorsByGroup[i] = groupSize;
              colorsRemaining -= groupSize;
            }
          }
          
          // Create color groups with distinct angles
          let currentAngle = 0;
          for (let group = 0; group < groupCount; group++) {
            // Each group is separated by 30-60°
            currentAngle += 30 + Math.floor(Math.random() * 30);
            
            // Alternate directions for more variety
            const direction = group % 2 === 0 ? 1 : -1;
            const groupAngle = currentAngle * direction;
            
            // Place colors within the group
            for (let i = 0; i < colorsByGroup[group]; i++) {
              // Group colors are within 5-15° of each other
              const offset = (i - colorsByGroup[group] / 2) * (5 + Math.random() * 10);
              hues.push((baseHSL.h + groupAngle + offset + 360) % 360);
            }
          }
          break;
          
        case 3: // "Wide Span with Golden Ratio"
          // Use golden ratio to create an aesthetically pleasing distribution
          // across a wider range than traditional analogous
          
          const goldenRatio = 0.618033988749895;
          const spanWidth = Math.random() * 100 + 60; // 60-160° total span
          
          // Generate colors using golden ratio for balanced distribution
          for (let i = 0; i < numColors - 1; i++) {
            const seed = (i + 1) * goldenRatio;
            const position = seed - Math.floor(seed); // 0-1 value
            
            // Map position to our span, centered on base hue
            const offset = (position - 0.5) * spanWidth;
            hues.push((baseHSL.h + offset + 360) % 360);
          }
          break;
          
        case 4: // "Split Analogous" - analogous on opposite sides of color wheel
          // Create analogous sets on both sides of the color wheel
          const splitBase = (baseHSL.h + 180) % 360; // Opposite side
          
          // Determine how many colors on each side
          const sideCount = Math.floor((numColors - 1) / 2);
          const remainder = (numColors - 1) % 2;
          
          // Range for each side
          const sideRange = 30 + Math.random() * 30; // 30-60° per side
          
          // Add colors on primary side
          for (let i = 0; i < sideCount + remainder; i++) {
            const position = (i + 1) / (sideCount + remainder + 1);
            const angle = sideRange * position;
            // Random direction on primary side
            const direction = Math.random() > 0.5 ? 1 : -1;
            hues.push((baseHSL.h + (angle * direction) + 360) % 360);
          }
          
          // Add colors on opposite side
          for (let i = 0; i < sideCount; i++) {
            const position = (i + 1) / (sideCount + 1);
            const angle = sideRange * position;
            // Random direction on opposite side
            const direction = Math.random() > 0.5 ? 1 : -1;
            hues.push((splitBase + (angle * direction) + 360) % 360);
          }
          break;
          
        case 5: // "Random Walk Analogous"
          // Create colors through a random walk from the base hue
          
          // The helper functions are now defined outside this block
          
          let currentHue = baseHSL.h;
          
          for (let i = 0; i < numColors - 1; i++) {
            // Take a random step, but bias toward one direction
            const bias = Math.random() > 0.3 ? 1 : -1; // 70% chance of positive direction
            const stepSize = Math.random() * 20 + 10; // 10-30° steps
            
            currentHue = (currentHue + (stepSize * bias) + 360) % 360;
            hues.push(currentHue);
          }
          
          // If the walk went too far, replace one color to maintain analogous feel
          const maxRange = 120; // Maximum acceptable range for analogous
          const totalSpan = getHueSpan(hues);
          
          if (totalSpan > maxRange) {
            // Replace the furthest color with one closer to base
            const furthestIdx = findFurthestHueIndex(hues, baseHSL.h);
            if (furthestIdx > 0) { // Don't replace the base color
              const newHue = (baseHSL.h + (Math.random() * 40 - 20) + 360) % 360;
              hues[furthestIdx] = newHue;
            }
          }
          break;
      }
      
      // Remove the duplicate helper functions here
      break;
    case 'triadic':
      // Completely new triadic palette generation for maximum variety
      hues = [baseHSL.h];
      
      // Choose a completely different strategy each time
      const triadStrategy = Math.floor(Math.random() * 6);
      
      switch (triadStrategy) {
        case 0: // "Classic Triad with Variance"
          // Create a traditional triad but with significant angle variance
          const angleVariance = Math.random() * 30 - 15; // ±15°
          const triad1 = (baseHSL.h + 120 + angleVariance) % 360;
          const triad2 = (baseHSL.h + 240 - angleVariance) % 360; // Opposite variance for balance
          
          // Add the main triadic points
          hues.push(triad1, triad2);
          
          // Add intermediate points if needed
          if (numColors > 3) {
            // Decide where to put intermediate colors
            const placement = Math.floor(Math.random() * 3);
            
            switch (placement) {
              case 0: // Even distribution
                // Place remaining colors evenly around the wheel
                for (let i = 3; i < numColors; i++) {
                  // Divide the circle into numColors segments
                  const angle = (i * (360 / numColors)) % 360;
                  hues.push((baseHSL.h + angle) % 360);
                }
                break;
                
              case 1: // Cluster near primary points
                // Add colors clustered around the main triad points
                for (let i = 3; i < numColors; i++) {
                  // Choose which triad point to cluster near
                  const primary = Math.floor(Math.random() * 3);
                  const basePt = primary === 0 ? baseHSL.h : 
                                (primary === 1 ? triad1 : triad2);
                  
                  // Add a color with random offset
                  const offset = Math.random() * 30 - 15; // ±15°
                  hues.push((basePt + offset) % 360);
                }
                break;
                
              case 2: // Split triad points
                // Create split triadic colors
                const splitAmount = Math.random() * 20 + 10; // 10-30° split
                
                // Create split points for each triad
                const splits = [
                  (baseHSL.h - splitAmount + 360) % 360,
                  (baseHSL.h + splitAmount) % 360,
                  (triad1 - splitAmount + 360) % 360,
                  (triad1 + splitAmount) % 360,
                  (triad2 - splitAmount + 360) % 360,
                  (triad2 + splitAmount) % 360
                ];
                
                // Shuffle the splits for randomness
                for (let i = splits.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [splits[i], splits[j]] = [splits[j], splits[i]];
                }
                
                // Add the splits to fill remaining slots
                for (let i = 0; i < Math.min(splits.length, numColors - 3); i++) {
                  hues.push(splits[i]);
                }
                break;
            }
          }
          break;
          
        case 1: // "Asymmetric Triad"
          // Instead of 120° spacing, use asymmetric angles
          const asymAngle1 = 90 + Math.floor(Math.random() * 30); // 90-120°
          const asymAngle2 = 210 + Math.floor(Math.random() * 30); // 210-240°
          
          const asym1 = (baseHSL.h + asymAngle1) % 360;
          const asym2 = (baseHSL.h + asymAngle2) % 360;
          
          hues.push(asym1, asym2);
          
          // Add intermediate colors if needed
          if (numColors > 3) {
            // Create intervening colors between main points
            const pairs = [
              { start: baseHSL.h, end: asym1, distance: 0 },
              { start: asym1, end: asym2, distance: 0 },
              { start: asym2, end: baseHSL.h, distance: 0 }
            ];
            
            // Calculate the actual distances with wraparound
            pairs.forEach(pair => {
              let diff = pair.end - pair.start;
              if (diff < 0) diff += 360;
              pair.distance = diff;
            });
            
            // Sort pairs by distance (largest first)
            pairs.sort((a, b) => b.distance - a.distance);
            
            // Distribute remaining colors proportionally by distance
            const remaining = numColors - 3;
            let toAllocate = remaining;
            
            for (let i = 0; i < pairs.length && toAllocate > 0; i++) {
              const pair = pairs[i];
              const pairColors = Math.min(Math.ceil(remaining * (pair.distance / 360)), toAllocate);
              
              // Place colors along this segment
              for (let j = 1; j <= pairColors; j++) {
                const position = j / (pairColors + 1);
                const newHue = (pair.start + pair.distance * position) % 360;
                hues.push(newHue);
                toAllocate--;
              }
            }
          }
          break;
          
        case 2: // "Delta Triad"
          // Create a triangle with one smaller angle and two larger ones
          // This creates more visual interest than equal 120° spacing
          
          const smallAngle = 60 + Math.floor(Math.random() * 30); // 60-90°
          const largeAngle = (360 - smallAngle) / 2; // Each large angle
          
          const delta1 = (baseHSL.h + smallAngle) % 360;
          const delta2 = (baseHSL.h + smallAngle + largeAngle) % 360;
          
          hues.push(delta1, delta2);
          
          // For larger palettes, add intermediate colors
          if (numColors > 3) {
            // Generate colors using golden ratio for aesthetics
            const goldenRatio = 0.618033988749895;
            
            for (let i = 3; i < numColors; i++) {
              // Start from different seeds for variety
              const seed = i * goldenRatio;
              
              // Place a color at this position around the wheel
              const position = seed - Math.floor(seed); // 0-1 value
              const newHue = (position * 360) % 360;
              
              // Ensure minimum distance from existing hues
              let minDistance = 360;
              for (const h of hues) {
                const distance = Math.min(
                  Math.abs(newHue - h),
                  360 - Math.abs(newHue - h)
                );
                minDistance = Math.min(minDistance, distance);
              }
              
              // If too close to existing color, offset it
              if (minDistance < 20) {
                const adjusted = (newHue + 30) % 360;
                hues.push(adjusted);
              } else {
                hues.push(newHue);
              }
            }
          }
          break;
          
        case 3: // "Expanded Triad"
          // Create a classic triad but add related colors
          // to create a richer palette
          
          // Generate the base triad
          const exp1 = (baseHSL.h + 120 + (Math.random() * 20 - 10)) % 360;
          const exp2 = (baseHSL.h + 240 + (Math.random() * 20 - 10)) % 360;
          
          // Create expanded variations
          const variations = [
            // Base color variations
            (baseHSL.h + 15) % 360,
            (baseHSL.h - 15 + 360) % 360,
            // First triad variations
            (exp1 + 15) % 360,
            (exp1 - 15 + 360) % 360,
            // Second triad variations
            (exp2 + 15) % 360,
            (exp2 - 15 + 360) % 360
          ];
          
          // Add the main triad points first
          hues.push(exp1, exp2);
          
          // Add variations if needed
          if (numColors > 3) {
            // Shuffle variations for unpredictability
            for (let i = variations.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [variations[i], variations[j]] = [variations[j], variations[i]];
            }
            
            // Add variations to fill remaining slots
            for (let i = 0; i < Math.min(variations.length, numColors - 3); i++) {
              hues.push(variations[i]);
            }
          }
          break;
          
        case 4: // "Random Triad"
          // Create completely random triadic arrangements
          // Start with two completely random colors
          let randomAngle1 = 0;
          let randomAngle2 = 0;
          let diffBetween = 0;
          
          // Ensure they're not too close together
          do {
            randomAngle1 = Math.random() * 360;
            randomAngle2 = Math.random() * 360;
            
            const diff1 = Math.min(
              Math.abs(randomAngle1 - baseHSL.h),
              360 - Math.abs(randomAngle1 - baseHSL.h)
            );
            
            const diff2 = Math.min(
              Math.abs(randomAngle2 - baseHSL.h),
              360 - Math.abs(randomAngle2 - baseHSL.h)
            );
            
            diffBetween = Math.min(
              Math.abs(randomAngle1 - randomAngle2),
              360 - Math.abs(randomAngle1 - randomAngle2)
            );
          } while (diffBetween < 60);
          
          hues.push(randomAngle1, randomAngle2);
          
          // For larger palettes, add more random colors
          if (numColors > 3) {
            for (let i = 3; i < numColors; i++) {
              let newHue;
              let valid = false;
              let attempts = 0;
              
              while (!valid && attempts < 10) {
                newHue = Math.random() * 360;
                valid = true;
                
                // Check against all existing hues
                for (const h of hues) {
                  const distance = Math.min(
                    Math.abs(newHue - h),
                    360 - Math.abs(newHue - h)
                  );
                  
                  if (distance < 30) {
                    valid = false;
                    break;
                  }
                }
                
                attempts++;
              }
              
              hues.push(newHue);
            }
          }
          break;
          
        case 5: // "Harmonic Triad"
          // Using music-inspired harmony with traditional major/minor thirds
          // Major third: 4:5 ratio (approx 81°)
          // Minor third: 5:6 ratio (approx 64°)
          
          // Create a triad with these musical intervals
          const majorThird = 81;
          const minorThird = 64;
          
          // Randomize whether to use major-minor or minor-major pattern
          const useMajorFirst = Math.random() > 0.5;
          
          let harm1, harm2;
          if (useMajorFirst) {
            harm1 = (baseHSL.h + majorThird) % 360;
            harm2 = (harm1 + minorThird) % 360;
          } else {
            harm1 = (baseHSL.h + minorThird) % 360;
            harm2 = (harm1 + majorThird) % 360;
          }
          
          hues.push(harm1, harm2);
          
          // For larger palettes, continue the pattern
          if (numColors > 3) {
            let currentHue = harm2;
            for (let i = 3; i < numColors; i++) {
              // Alternate major/minor thirds
              const interval = i % 2 === (useMajorFirst ? 0 : 1) ? majorThird : minorThird;
              currentHue = (currentHue + interval) % 360;
              hues.push(currentHue);
            }
          }
          break;
      }
      break;
    case 'tetradic':
      // Enhanced tetradic palette generation with much greater variety
      // Start with the base hue
      hues = [baseHSL.h];
      
      // Create a randomized tetrad
      // Instead of strict 90° separation, vary each angle slightly
      const tetradVariance1 = Math.random() * 15 - 7.5; // ±7.5°
      const tetradVariance2 = Math.random() * 15 - 7.5;
      const tetradVariance3 = Math.random() * 15 - 7.5;
      
      // Calculate the tetrad points with variance
      const tetrad1 = (baseHSL.h + 90 + tetradVariance1) % 360;
      const tetrad2 = (baseHSL.h + 180 + tetradVariance2) % 360;
      const tetrad3 = (baseHSL.h + 270 + tetradVariance3) % 360;
      
      // For small palettes, just use the tetrad colors in priority order
      if (numColors <= 4) {
        if (numColors >= 2) hues.push(tetrad2); // Add the complement first (most contrast)
        if (numColors >= 3) hues.push(tetrad1); // Then add one of the square points
        if (numColors >= 4) hues.push(tetrad3); // Then add the final point
      } else {
        // For larger palettes, use a more sophisticated strategy
        
        // First add the main tetrad points
        hues.push(tetrad1, tetrad2, tetrad3);
        
        // Choose a random distribution strategy
        const strategy = Math.floor(Math.random() * 3);
        
        switch (strategy) {
          case 0: // "Interpolation" - add colors between tetrad points
            // Determine how many additional colors to place
            const remaining = numColors - 4;
            
            // Find pairs that would benefit from intermediates
            // Create an array of all tetrad points, sorted
            const sortedPoints = [baseHSL.h, tetrad1, tetrad2, tetrad3].sort((a, b) => a - b);
            
            // Calculate distance between each pair
            const pairs = [];
            for (let i = 0; i < 4; i++) {
              const start = sortedPoints[i];
              const end = sortedPoints[(i + 1) % 4];
              
              // Calculate arc length with wraparound
              let diff = end - start;
              if (diff < 0) diff += 360;
              
              // Add to our pairs array
              pairs.push({
                start,
                end,
                distance: diff,
                index: i
              });
            }
            
            // Sort pairs by distance (largest first)
            pairs.sort((a, b) => b.distance - a.distance);
            
            // Distribute remaining colors proportionally among pairs
            let remainingToAdd = remaining;
            const allocations = pairs.map(pair => {
              // Allocate based on relative distance
              const allocation = Math.floor(remainingToAdd * (pair.distance / 360));
              remainingToAdd -= allocation;
              return { ...pair, allocation };
            });
            
            // Assign any leftovers to the largest gap
            if (remainingToAdd > 0) {
              allocations[0].allocation += remainingToAdd;
            }
            
            // Generate intermediate colors for each pair
            for (const pair of allocations) {
              if (pair.allocation <= 0) continue;
              
              for (let j = 1; j <= pair.allocation; j++) {
                // Calculate position with some randomness
                const position = j / (pair.allocation + 1);
                const jitter = Math.random() * 0.2 - 0.1; // ±10%
                const adjustedPosition = Math.max(0.05, Math.min(0.95, position + jitter));
                
                // Calculate the new hue
                const newHue = (pair.start + pair.distance * adjustedPosition) % 360;
                hues.push(newHue);
              }
            }
            break;
            
          case 1: // "Clustered Tetrad" - create small variations around each tetrad point
            // Create clusters around each tetrad point
            const allPoints = [baseHSL.h, tetrad1, tetrad2, tetrad3];
            
            // Distribute remaining colors among clusters
            const pointsRemaining = numColors - 4;
            const pointsPerCluster = Math.ceil(pointsRemaining / 4);
            
            // Create variations for each tetrad point
            for (let i = 0; i < 4; i++) {
              const basePoint = allPoints[i];
              
              // Add variations if we still have points to add
              for (let j = 0; j < pointsPerCluster; j++) {
                if (hues.length >= numColors) break;
                
                // Create a variation with random offset
                const offset = Math.random() * 24 - 12; // ±12°
                const newHue = (basePoint + offset + 360) % 360;
                
                // Avoid too-similar hues
                if (!hues.some(h => Math.abs(h - newHue) < 5 || Math.abs(h - newHue) > 355)) {
                  hues.push(newHue);
                }
              }
            }
            break;
            
          case 2: // "Dynamic Distribution" - distribute using golden ratio for aesthetic appeal
            // Use golden ratio distribution
            const goldenRatio = 0.618033988749895;
            
            // Start with tetrad points
            const mainPoints = [baseHSL.h, tetrad1, tetrad2, tetrad3];
            
            // For remaining colors, use golden ratio distribution
            for (let i = 4; i < numColors; i++) {
              // Get a unique position using golden ratio
              const goldPosition = (i * goldenRatio) % 1.0;
              const huePosition = goldPosition * 360;
              
              // Find the closest tetrad point
              let closestPoint = mainPoints[0];
              let minDistance = 360;
              
              for (const point of mainPoints) {
                const distance = Math.min(
                  Math.abs(huePosition - point),
                  360 - Math.abs(huePosition - point)
                );
                
                if (distance < minDistance) {
                  minDistance = distance;
                  closestPoint = point;
                }
              }
              
              // Create a color that's a blend between the position and the closest point
              // This creates harmony while maintaining variety
              const blendFactor = 0.7; // 70% golden ratio position, 30% closest tetrad
              const blendedHue = (huePosition * blendFactor + closestPoint * (1 - blendFactor)) % 360;
              
              hues.push(blendedHue);
            }
            break;
        }
      }
      break;
    case 'splitComplementary':
      // Enhanced split complementary generation with much greater variety
      // Start with the base hue
      hues = [baseHSL.h];
      
      // Create a randomized split complement
      // Traditional split is complement ±30°, but we'll randomize this
      const splitAngle = 30 + (Math.random() * 20 - 10); // 20-40° split
      const splitComplementHue = (baseHSL.h + 180) % 360;
      
      // Calculate the two split complementary colors
      const split1 = (splitComplementHue - splitAngle + 360) % 360;
      const split2 = (splitComplementHue + splitAngle) % 360;
      
      // For small palettes, just use the main colors
      if (numColors <= 3) {
        if (numColors >= 2) hues.push(split1);
        if (numColors >= 3) hues.push(split2);
      } else {
        // For larger palettes, use more sophisticated strategies
        
        // Add the split complementary colors
        hues.push(split1, split2);
        
        // Choose a strategy for the remaining colors
        const strategy = Math.floor(Math.random() * 3);
        
        switch (strategy) {
          case 0: // "Triangle Balance" - distribute colors within the split complement triangle
            // Calculate the remaining colors to add
            const remaining = numColors - 3;
            
            // For triangle strategy, we'll add colors inside the triangle
            // formed by the base and two split complements
            
            for (let i = 0; i < remaining; i++) {
              // Random barycentric coordinates for the triangle
              const a = Math.random();
              const b = Math.random() * (1 - a);
              const c = 1 - a - b;
              
              // Interpolate using barycentric coordinates
              // This gives a point inside the triangle on the color wheel
              // Convert to cartesian for interpolation
              const points = [baseHSL.h, split1, split2].map(h => {
                const rad = h * Math.PI / 180;
                return {
                  x: Math.cos(rad),
                  y: Math.sin(rad)
                };
              });
              
              // Interpolate
              const x = a * points[0].x + b * points[1].x + c * points[2].x;
              const y = a * points[0].y + b * points[1].y + c * points[2].y;
              
              // Convert back to angle
              let newHue = Math.atan2(y, x) * 180 / Math.PI;
              if (newHue < 0) newHue += 360;
              
              hues.push(newHue);
            }
            break;
            
          case 1: // "Expanded Split" - create additional splits around the complement
            // Calculate how many additional splits to create
            const expandedSplitCount = numColors - 3;
            
            // Create additional split points at varying distances
            for (let i = 0; i < expandedSplitCount; i++) {
              // Alternate which side of the complement to place the new color
              const side = i % 2 === 0 ? -1 : 1;
              
              // Calculate the angle from the complement
              // Start narrow and gradually widen
              const angle = splitAngle * 0.5 + (i * 0.5 * splitAngle);
              
              // Add randomness to the angle
              const jitter = Math.random() * 10 - 5;
              
              // Calculate the new color
              const newHue = (splitComplementHue + (side * angle) + jitter + 360) % 360;
              
              hues.push(newHue);
            }
            break;
            
          case 2: // "Bridge" - add colors that bridge the large gap between base and splits
            // The gap between the base and split complements is quite large
            // We'll add colors to bridge this gap
            
            // First sort the hues so we can identify the gaps
            const sortedHues = [baseHSL.h, split1, split2].sort((a, b) => a - b);
            
            // Calculate the gaps (with wraparound)
            const gaps = [];
            for (let i = 0; i < 3; i++) {
              const start = sortedHues[i];
              const end = sortedHues[(i + 1) % 3];
              
              // Handle wraparound
              let diff = end - start;
          if (diff < 0) diff += 360;
              
              gaps.push({
                start,
                end,
                size: diff
              });
            }
            
            // Sort gaps by size (largest first)
            gaps.sort((a, b) => b.size - a.size);
            
            // Distribute remaining colors proportionally among gaps
            const gapRemaining = numColors - 3;
            let allocated = 0;
            
            for (const gap of gaps) {
              // Calculate how many colors to allocate to this gap
              const toAllocate = Math.floor(gapRemaining * (gap.size / 360));
              
              // Add colors to bridge this gap
              for (let i = 0; i < toAllocate; i++) {
                if (allocated >= gapRemaining) break;
                
                // Calculate position along the gap
                const position = (i + 1) / (toAllocate + 1);
                
                // Add randomness to position
                const jitter = Math.random() * 0.2 - 0.1;
                const adjustedPosition = Math.max(0.05, Math.min(0.95, position + jitter));
                
                // Calculate the new hue
                const newHue = (gap.start + gap.size * adjustedPosition) % 360;
                hues.push(newHue);
                allocated++;
              }
            }
            
            // If we still have colors to allocate, put them in the largest gap
            while (allocated < gapRemaining) {
              // Find a position in the largest gap that isn't too close to existing hues
              const largestGap = gaps[0];
              let newHue;
              let acceptable = false;
              let attempts = 0;
              
              // Try to find an acceptable position
              while (!acceptable && attempts < 20) {
                const position = Math.random();
                newHue = (largestGap.start + largestGap.size * position) % 360;
                attempts++;
                
                // Check if it's too close to existing hues
                acceptable = true;
                for (const h of hues) {
                  const distance = Math.min(Math.abs(newHue - h), 360 - Math.abs(newHue - h));
                  if (distance < 10) {
                    acceptable = false;
                    break;
                  }
                }
              }
              
              // Even if we couldn't find a perfect position, use the last one we calculated
              hues.push(newHue as number);
              allocated++;
            }
            break;
        }
      }
      break;
  }
  
  // Enforce better hue spacing with our improved algorithm
  const spacedHues = enforceHueSpacing(hues, paletteType === 'monochromatic' ? 0 : MIN_HUE_SPACING);
  
  // Create role-based lightness and saturation distributions
  const lightnessValues = distributeLightness(numColors);
  const saturationValues = distributeSaturation(numColors, baseHSL.s);
  
  // Shuffle the lightness array to avoid predictable patterns
  // but ensure the darkest color is applied to the dominant hue (first hue)
  const shuffledLightness = [...lightnessValues];
  for (let i = 1; i < shuffledLightness.length; i++) {
    const j = 1 + Math.floor(Math.random() * (shuffledLightness.length - 1));
    [shuffledLightness[i], shuffledLightness[j]] = [shuffledLightness[j], shuffledLightness[i]];
  }
  
  // Always make sure we have at least one neutral/desaturated color for balance
  // Choose one of the mid-tone colors to make neutral
  const neutralIndex = numColors >= 4 ? 
    1 + Math.floor(Math.random() * (numColors - 2)) : // Random middle color for larger palettes
    (numColors >= 3 ? 1 : 0); // First non-dominant color for small palettes
  
  // Create a balanced palette with distinct roles
  for (let i = 0; i < numColors; i++) {
    // Assign roles based on position
    let role: string;
    
    if (i === 0) {
      role = 'dominant';
    } else if (i === numColors - 1) {
      role = 'accent';
    } else if (i === neutralIndex) {
      role = 'neutral';
    } else if (i === numColors - 2 && numColors > 3) {
      role = 'highlight';
    } else {
      role = 'transition';
    }
    
    // Apply role constraints to saturation and lightness
    const constraints = ROLE_CONSTRAINTS[role];
    
    let lightness, saturation;
    
    if (paletteType === 'monochromatic') {
      // Completely new monochromatic palette strategies with dramatic variety
      // Use the strategy that was chosen during hue generation
      const monoStrategy = (hues as any).satLightStrategy || Math.floor(Math.random() * 8);
      const baseS = (hues as any).baseS || baseHSL.s;
      const baseL = (hues as any).baseL || baseHSL.l;
      
      switch (monoStrategy) {
        case 0: // "Full Gradient" - smooth gradient from light to dark
          // Calculate position in the gradient (0-1)
          const gradientPosition = i / (numColors - 1);
          
          // Map to lightness range with maximum spread
          lightness = 95 - gradientPosition * 80; // 95-15% range
          
          // For saturation, use a curve peaking in the middle
          const satCurve = 1 - 2 * Math.abs(gradientPosition - 0.5);
          saturation = Math.max(10, Math.min(100, baseS + (satCurve * 20)));
          break;
          
        case 1: // "High Contrast" - alternating light and dark
          // Alternate between light and dark
          lightness = i % 2 === 0 ? 
            (80 - (i * 5)) : // Light colors getting slightly darker
            (25 + (i * 3));  // Dark colors getting slightly lighter
          
          // Inverse saturation relationship
          saturation = i % 2 === 0 ?
            Math.max(10, baseS - 15) : // Less saturated light colors
            Math.min(100, baseS + 25); // More saturated dark colors
          break;
          
        case 2: // "Dramatic Saturation" - wide range of saturation values
          // Keep similar lightness but vary saturation dramatically
          lightness = baseL + (Math.random() * 30 - 15);
          lightness = Math.max(15, Math.min(90, lightness));
          
          // Create a wide range of saturation values
          const satPosition = i / (numColors - 1);
          saturation = 10 + satPosition * 90; // 10-100% range
          
          // Add small randomness to saturation
          saturation += Math.random() * 10 - 5;
          saturation = Math.max(5, Math.min(100, saturation));
          break;
          
        case 3: // "S-Curve" - non-linear lightness distribution
          // Use an S-curve for more interesting lightness distribution
          const normalizedPos = i / (numColors - 1);
          
          // Apply sigmoid function for S-curve
          // This creates a more dramatic middle section
          const sigmoid = 1 / (1 + Math.exp(-10 * (normalizedPos - 0.5)));
          lightness = 90 - sigmoid * 75; // 90-15% range
          
          // For saturation, use a wavelike pattern
          saturation = baseS + Math.sin(normalizedPos * Math.PI * 2) * 25;
          saturation = Math.max(10, Math.min(95, saturation));
          break;
          
        case 4: // "Vintage Photo" - low saturation, high contrast
          // Create an aged/vintage look with low saturation
          // and dramatic contrast
          
          // Wide lightness range
          lightness = 90 - (i / (numColors - 1)) * 75;
          
          // Low saturation throughout
          saturation = Math.max(5, Math.min(40, baseS - 30));
          
          // Add sepia tone effect with slight hue shift
          // (This is done in the hue generation part)
          break;
          
        case 5: // "Vibrant Mono" - high saturation throughout
          // Create a highly saturated, vibrant look
          
          // Full lightness range but weighted toward middle-light values
          const vibrantPos = i / (numColors - 1);
          const skewedPos = Math.pow(vibrantPos, 0.7); // Weight toward lighter
          lightness = 85 - skewedPos * 65; // 85-20% range
          
          // High saturation throughout
          saturation = Math.max(60, Math.min(100, baseS + 20));
          break;
          
        case 6: // "Bold Accents" - mostly neutral with few bold accents
          // Create a palette with mostly desaturated colors
          // and 1-2 highly saturated accents
          
          // Determine if this should be an accent color
          const isAccent = (i === 1 || (numColors > 4 && i === numColors - 2));
          
          if (isAccent) {
            // Accent colors are more saturated
            saturation = Math.min(100, baseS + 30);
            // And often darker or brighter
            lightness = i === 1 ? 
              Math.max(15, baseL - 15) : // First accent darker
              Math.min(85, baseL + 25);  // Last accent lighter
          } else {
            // Non-accent colors are more muted
            saturation = Math.max(10, baseS - 40);
            
            // Create a gradient of lightness for non-accents
            const nonAccentCount = numColors - 2; // Excluding base and accents
            const nonAccentIndex = i > 1 ? i - 2 : i;
            lightness = 30 + (nonAccentIndex / Math.max(1, nonAccentCount)) * 50;
          }
          break;
          
        case 7: // "Two-Tone" - two distinct color groups
          // Split the palette into two distinct lightness groups
          // with a gap between them
          
          // Determine group (first half vs second half)
          const inFirstGroup = i < numColors / 2;
          
          if (inFirstGroup) {
            // First group: lighter colors
            const groupPos = i / Math.max(1, Math.floor(numColors / 2) - 1);
            lightness = 90 - groupPos * 25; // 90-65% range
            
            // First group: less saturated
            saturation = Math.max(15, baseS - 20);
          } else {
            // Second group: darker colors
            const groupPos = (i - Math.floor(numColors / 2)) / 
                           Math.max(1, numColors - Math.floor(numColors / 2) - 1);
            lightness = 40 - groupPos * 25; // 40-15% range
            
            // Second group: more saturated
            saturation = Math.min(95, baseS + 20);
          }
          break;
          
        default:
          // Fallback to original approach
          lightness = Math.min(constraints.maxLightness, 
                      Math.max(constraints.minLightness, shuffledLightness[i]));
          
          // And less variation in saturation
          const scaledHSL = scaleSaturation(
            { h: spacedHues[i], s: baseHSL.s, l: lightness }, 
            role
          );
          saturation = scaledHSL.s;
      }
    } else {
      // For other palette types, use the original approach
      lightness = Math.min(constraints.maxLightness, 
                  Math.max(constraints.minLightness, shuffledLightness[i]));
      
      // Apply dynamic saturation scaling
      const scaledHSL = scaleSaturation(
        { h: spacedHues[i], s: saturationValues[i], l: lightness }, 
        role
      );
      saturation = scaledHSL.s;
    }
    
    colors.push({
      hex: hslToHex(spacedHues[i], saturation, lightness),
      rgb: hslToRgb(spacedHues[i], saturation, lightness),
      hsl: { h: spacedHues[i], s: saturation, l: lightness }
    });
  }
  
  // Apply final contrast improvements
  return validateAndImproveContrast(colors);
}

function hslToHex(h: number, s: number, l: number): string {
  const rgb = hslToRgb(h, s, l);
  return `#${rgb.r.toString(16).padStart(2, '0')}${rgb.g.toString(16).padStart(2, '0')}${rgb.b.toString(16).padStart(2, '0')}`;
}

function hslToRgb(h: number, s: number, l: number): { r: number; g: number; b: number } {
  s /= 100;
  l /= 100;
  
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
  const m = l - c / 2;
  
  let r = 0, g = 0, b = 0;
  
  if (h >= 0 && h < 60) {
    r = c; g = x; b = 0;
  } else if (h >= 60 && h < 120) {
    r = x; g = c; b = 0;
  } else if (h >= 120 && h < 180) {
    r = 0; g = c; b = x;
  } else if (h >= 180 && h < 240) {
    r = 0; g = x; b = c;
  } else if (h >= 240 && h < 300) {
    r = x; g = 0; b = c;
  } else if (h >= 300 && h < 360) {
    r = c; g = 0; b = x;
  }
  
  return {
    r: Math.round((r + m) * 255),
    g: Math.round((g + m) * 255),
    b: Math.round((b + m) * 255)
  };
}

// Helper function to get hue span (used in analogous strategies)
function getHueSpan(hueArray: number[]): number {
  let min = 360;
  let max = 0;
  
  // Find min and max hue values
  for (const hue of hueArray) {
    if (hue < min) min = hue;
    if (hue > max) max = hue;
  }
  
  // Calculate span, accounting for wraparound
  const directSpan = max - min;
  const wraparoundSpan = min + (360 - max);
  
  return Math.min(directSpan, wraparoundSpan);
}

// Helper function to find the furthest hue index
function findFurthestHueIndex(hueArray: number[], referenceHue: number): number {
  let maxDistance = 0;
  let furthestIndex = 0;
  
  for (let i = 0; i < hueArray.length; i++) {
    const distance = Math.min(
      Math.abs(hueArray[i] - referenceHue),
      360 - Math.abs(hueArray[i] - referenceHue)
    );
    
    if (distance > maxDistance) {
      maxDistance = distance;
      furthestIndex = i;
    }
  }
  
  return furthestIndex;
}

// Now modify the case in the switch statement to use these external functions
// Replace the case 5 in the analogous palette type:

case 5: // "Random Walk Analogous"
  // Create colors through a random walk from the base hue
  
  // The helper functions are now defined outside this block
  
  let currentHue = baseHSL.h;
  
  for (let i = 0; i < numColors - 1; i++) {
    // Take a random step, but bias toward one direction
    const bias = Math.random() > 0.3 ? 1 : -1; // 70% chance of positive direction
    const stepSize = Math.random() * 20 + 10; // 10-30° steps
    
    currentHue = (currentHue + (stepSize * bias) + 360) % 360;
    hues.push(currentHue);
  }
  
  // If the walk went too far, replace one color to maintain analogous feel
  const maxRange = 120; // Maximum acceptable range for analogous
  const totalSpan = getHueSpan(hues);
  
  if (totalSpan > maxRange) {
    // Replace the furthest color with one closer to base
    const furthestIdx = findFurthestHueIndex(hues, baseHSL.h);
    if (furthestIdx > 0) { // Don't replace the base color
      const newHue = (baseHSL.h + (Math.random() * 40 - 20) + 360) % 360;
      hues[furthestIdx] = newHue;
    }
  }
  break;

// Now completely update the generateColorPalette function with significant randomization
export function generateColorPalette(
  baseColor: string,
  options: {
    numColors?: number;
    useNamedColors?: boolean;
    namedColorRatio?: number;
    paletteType?: 'monochromatic' | 'complementary' | 'analogous' | 'triadic' | 'tetradic' | 'splitComplementary';
    colorData?: ColorEntry[];
    enforceMinContrast?: boolean;
    temperature?: 'warm' | 'cool' | 'neutral' | 'mixed';
  } = {}
): Color[] {
  const {
    numColors = 5,
    useNamedColors = true,
    namedColorRatio = 0.5,
    paletteType = 'analogous',
    colorData = ACCURATE_COLOR_DATA,
    enforceMinContrast = true,
    temperature = 'mixed'
  } = options;

  // Generate a unique ID for this generation to ensure different results each time
  const uniqueId = Date.now() + Math.random();
  
  // Normalize the base color format
  const normalizedBaseColor = baseColor.toUpperCase();

  // Try to find exact match for base color first
  const exactMatch = findExactColorMatch(baseColor, colorData);
  
  // Convert base color to HSL
  const baseHSL = hexToHSL(baseColor);
  
  // MAJOR IMPROVEMENT: Apply strong randomization to ALL palette generations
  // This ensures each generation is significantly different
  
  // Apply a different randomization strategy for each palette type
  if (paletteType === 'monochromatic') {
    // For monochromatic, just vary saturation and lightness slightly
    baseHSL.s = Math.min(100, Math.max(20, baseHSL.s + (Math.random() * 10 - 5)));
    baseHSL.l = Math.min(80, Math.max(30, baseHSL.l + (Math.random() * 10 - 5)));
  } else if (paletteType === 'complementary') {
    // For complementary, apply major hue shift and saturation/lightness variation
    baseHSL.h = (baseHSL.h + (Math.random() * 40 - 20)) % 360;
    if (baseHSL.h < 0) baseHSL.h += 360;
    baseHSL.s = Math.min(100, Math.max(20, baseHSL.s + (Math.random() * 30 - 15)));
    baseHSL.l = Math.min(80, Math.max(30, baseHSL.l + (Math.random() * 20 - 10)));
  } else if (paletteType === 'analogous') {
    // For analogous, use moderate hue shift
    baseHSL.h = (baseHSL.h + (Math.random() * 30 - 15)) % 360;
    if (baseHSL.h < 0) baseHSL.h += 360;
    baseHSL.s = Math.min(100, Math.max(20, baseHSL.s + (Math.random() * 25 - 10)));
    baseHSL.l = Math.min(80, Math.max(30, baseHSL.l + (Math.random() * 15 - 5)));
  } else if (paletteType === 'triadic') {
    // For triadic, use major hue positioning variation
    baseHSL.h = (baseHSL.h + (Math.random() * 50 - 25)) % 360;
    if (baseHSL.h < 0) baseHSL.h += 360;
    baseHSL.s = Math.min(100, Math.max(20, baseHSL.s + (Math.random() * 25 - 15)));
    baseHSL.l = Math.min(80, Math.max(30, baseHSL.l + (Math.random() * 15 - 5)));
  } else if (paletteType === 'tetradic') {
    // For tetradic, use extreme hue redistribution
    baseHSL.h = (baseHSL.h + (Math.random() * 60 - 30)) % 360;
    if (baseHSL.h < 0) baseHSL.h += 360;
    baseHSL.s = Math.min(100, Math.max(20, baseHSL.s + (Math.random() * 30 - 15)));
    baseHSL.l = Math.min(80, Math.max(30, baseHSL.l + (Math.random() * 20 - 10)));
  } else if (paletteType === 'splitComplementary') {
    // For split complementary, use wide hue spacing variation
    baseHSL.h = (baseHSL.h + (Math.random() * 45 - 20)) % 360;
    if (baseHSL.h < 0) baseHSL.h += 360;
    baseHSL.s = Math.min(100, Math.max(20, baseHSL.s + (Math.random() * 30 - 15)));
    baseHSL.l = Math.min(80, Math.max(30, baseHSL.l + (Math.random() * 15 - 5)));
  }
  
  // Save the original passed color
  const originalColor = {
    hex: normalizedBaseColor,
    rgb: hslToRgb(hexToHSL(normalizedBaseColor).h, hexToHSL(normalizedBaseColor).s, hexToHSL(normalizedBaseColor).l),
    hsl: hexToHSL(normalizedBaseColor),
    name: exactMatch?.name
  };
  
  // Create a base color object with our randomized HSL values
  const baseColorObj: Color = {
    hex: hslToHex(baseHSL.h, baseHSL.s, baseHSL.l),
    rgb: hslToRgb(baseHSL.h, baseHSL.s, baseHSL.l),
    hsl: baseHSL,
    name: exactMatch?.name
  };
  
  // Generate colors algorithmically with extreme randomization
  const generatedColors = generateColorsByType(baseHSL, numColors, paletteType);
  
  // Replace the first color with our preserved original base color
  generatedColors[0] = originalColor;
  
  // Apply temperature adjustment if specified
  const temperatureAdjusted = temperature !== 'mixed' ? 
    adjustTemperature(generatedColors, temperature) : 
    generatedColors;
  
  // Ensure the first color is still our original base color
  temperatureAdjusted[0] = originalColor;
  
  // If not using named colors, just return the generated colors with improved contrast
  if (!useNamedColors) {
    const contrastImproved = enforceMinContrast ? validateAndImproveContrast(temperatureAdjusted) : temperatureAdjusted;
    // Ensure base color is preserved
    contrastImproved[0] = originalColor;
    return contrastImproved;
  }

  // If we have an exact match, ensure it's used for the base color
  if (exactMatch) {
    temperatureAdjusted[0] = exactMatch;
  }

  // Find similar named colors with some variety based on our seed
  const numNamedColors = Math.max(1, Math.floor(numColors * namedColorRatio));
  
  // Find named colors that complement our base color
  const namedColors = findSimilarNamedColors(baseHSL, numNamedColors, colorData);
  
  // Replace any low-quality generated colors with better named alternatives
  const enhancedGenerated = enhanceGeneratedColors(temperatureAdjusted, colorData);
  
  // Ensure base color is preserved
  enhancedGenerated[0] = exactMatch || originalColor;
  
  // Mix generated and named colors
  const mixedColors = mixColors(enhancedGenerated, namedColors);
  
  // Ensure base color is preserved
  mixedColors[0] = exactMatch || originalColor;
  
  // As a final step, ensure we have good contrast between adjacent colors
  const finalPalette = enforceMinContrast ? validateAndImproveContrast(mixedColors) : mixedColors;
  
  // One final check to ensure base color is preserved
  finalPalette[0] = exactMatch || originalColor;
  
  // Add evaluation data to help debug and improve color generation
  const evaluation = analyzePalette(finalPalette);
  if (finalPalette[0]) {
    (finalPalette[0] as any).evaluation = evaluation;
  }
  
  return finalPalette;
} 

export function regenerateWithLockedColors(
  currentPalette: Color[],
  lockedIndices: number[],
  options: {
    numColors?: number;
    useNamedColors?: boolean;
    namedColorRatio?: number;
    paletteType?: 'monochromatic' | 'complementary' | 'analogous' | 'triadic' | 'tetradic' | 'splitComplementary';
    colorData?: ColorEntry[];
    enforceMinContrast?: boolean;
    temperature?: 'warm' | 'cool' | 'neutral' | 'mixed';
  } = {}
): Color[] {
  // Implementation for regenerating palette with locked colors
  // This function should return a new palette with the specified colors locked
  // You can use the existing generateColorPalette function to generate a new palette
  // and then lock the specified colors
  // ...
  return [];
} 